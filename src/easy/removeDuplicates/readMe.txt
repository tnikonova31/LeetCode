Учитывая целочисленный массив, nums отсортированный в порядке неубывания ,
удалите дубликаты на месте так, чтобы каждый уникальный элемент появлялся только один раз .
Относительный порядок элементов должен оставаться неизменным .
Затем верните количество уникальных элементов вnums .

Учитывая количество уникальных элементов , чтобы nums быть k принятым, вам необходимо сделать следующее:

Измените массив nums так, чтобы первые k элементы nums содержали уникальные элементы в том порядке,
в котором они присутствовали nums изначально. Остальные элементы nums не важны, как и размер nums.
Возврат k.

Пользовательский судья:
Судья проверит ваше решение с помощью следующего кода:

int[] nums = [...]; // Входной массив
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины
int k = RemoveDuulates (nums); // Вызывает вашу реализацию

утверждать k == ожидаемые числа.длина;
for (int i = 0; i < k; i++) {
    утверждать nums[i] == ожидаемыеNums[i];
}
Если все утверждения пройдены, ваше решение будет принято .


Пример 1:

Входные данные: nums = [1,1,2]
 Выходные данные: 2, nums = [1,2,_]
 Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums равны 1 и 2 соответственно.
Не имеет значения, что вы оставите после возвращенного k (следовательно, они являются подчеркиванием).
Пример 2:

Ввод: nums = [0,0,1,1,1,2,2,3,3,4]
 Выход: 5, nums = [0,1,2,3,4,_,_,_,_, _]
 Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов числа nums равны 0, 1, 2, 3 и 4 соответственно.
Не имеет значения, что вы оставите после возвращенного k (следовательно, они являются подчеркиванием).