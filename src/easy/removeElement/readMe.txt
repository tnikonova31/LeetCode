Учитывая целочисленный массив nums и целое число val, удалите все вхождения val in nums in-place .
Порядок элементов может быть изменен. Затем вернуть количество элементов, в nums которых не равны val .

Учитывая количество элементов, в nums которых не равны val быть k, чтобы вас приняли, вам нужно сделать следующие вещи:

Измените массив nums так, чтобы первые k элементы nums содержали элементы, не равные val.
Остальные элементы nums не так важны, как и размер nums.
Вернуться k.

Судья проверит ваше решение с помощью следующего кода:

int[] числа = [...]; // Входной массив
интервал = ...; // Значение для удаления
int[] ожидаемые числа = [...]; // Ожидаемый ответ правильной длины.
                            // Он отсортирован без значений, равных val.
int k = easy.removeElement (числа, значения); // Вызывает вашу реализацию
утверждать k == ожидаемоеNums.length;
сортировать (числа, 0, к); // Сортируем первые k элементов nums
for (int я = 0; я <фактическая длина; я ++) {
    утверждать nums[i] == ожидаемоеNums[i];
}
Если все утверждения пройдены, то ваше решение будет принято .


Пример 1:
Ввод: nums = [3,2,2,3], val = 3
 Вывод: 2, nums = [2,2,_,_]
 Объяснение: Ваша функция должна возвращать k = 2, причем первые два элемента nums равны 2.
Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).

Пример 2:
Ввод: nums = [0,1,2,2,3,0,4,2], val = 2
 Выход: 5, nums = [0,1,4,0,3,_,_,_]
 Объяснение: Ваша функция должна возвращать k = 5, причем первые пять элементов nums содержат 0, 0, 1, 3 и 4.
Обратите внимание, что пять элементов могут быть возвращены в любом порядке.
Неважно, что вы оставляете за возвращенным k (следовательно, это символы подчеркивания).

Ограничения:
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100